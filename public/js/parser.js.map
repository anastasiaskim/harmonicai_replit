{
  "version": 3,
  "sources": ["../../client/src/lib/textParser.ts", "../../client/src/parser-index.ts"],
  "sourcesContent": ["/**\n * Text Parser Module\n * Provides utilities for reading and parsing text files into sections\n */\n\n/**\n * Read a file and extract its content as text\n * \n * @param file The file to read\n * @returns A promise that resolves with the file content as a string\n */\nexport async function readFile(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n\n        reader.onload = (event) => {\n            if (event.target && typeof event.target.result === 'string') {\n                resolve(event.target.result);\n            } else {\n                reject(new Error(\"Failed to read file.\"));\n            }\n        };\n\n        reader.onerror = () => {\n            reject(new Error(\"Failed to read file.\"));\n        };\n\n        reader.readAsText(file);\n    });\n}\n\n/**\n * Section object representing a parsed section from the text\n */\nexport interface Section {\n    title: string;\n    content: string[];\n}\n\n/**\n * Parse text content into sections based on provided patterns\n * \n * @param text The text content to parse\n * @param patterns Array of regular expressions that identify section headings\n * @returns An object containing the sections with their content and pattern match information\n */\nexport function parseSections(\n    text: string, \n    patterns: RegExp[]\n): { \n    sections: { [title: string]: string[] };\n    patternMatches: { [title: string]: number };\n} {\n    const sections: { [title: string]: string[] } = {};\n    const patternMatches: { [title: string]: number } = {};\n    \n    // Handle empty text\n    if (!text || text.trim().length === 0) {\n        return { sections, patternMatches };\n    }\n    \n    // Split text into lines\n    const lines = text.split(/\\r?\\n/);\n    \n    let currentSection: string | null = null;\n    let currentContent: string[] = [];\n    let beforeFirstSection: string[] = [];\n    let foundFirstSection = false;\n\n    // Process each line\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        let isHeading = false;\n        \n        // Check against all patterns\n        for (let j = 0; j < patterns.length; j++) {\n            const pattern = patterns[j];\n            if (pattern.test(line)) {\n                isHeading = true;\n                \n                // If we already have a section, save it\n                if (currentSection) {\n                    sections[currentSection] = currentContent;\n                } else if (!foundFirstSection && beforeFirstSection.length > 0) {\n                    // Save content before first section as \"Introduction\"\n                    sections[\"Introduction\"] = beforeFirstSection;\n                }\n                \n                // Start a new section\n                currentSection = extractSectionTitle(line, j);\n                currentContent = [];\n                patternMatches[currentSection] = j;\n                foundFirstSection = true;\n                break;\n            }\n        }\n        \n        // If this wasn't a heading, add to current section or pre-section content\n        if (!isHeading) {\n            if (foundFirstSection) {\n                currentContent.push(line);\n            } else {\n                beforeFirstSection.push(line);\n            }\n        }\n    }\n    \n    // Add the final section\n    if (currentSection) {\n        sections[currentSection] = currentContent;\n    } else if (beforeFirstSection.length > 0) {\n        // If we didn't find any sections, treat the whole content as \"Chapter 1\"\n        sections[\"Chapter 1\"] = beforeFirstSection;\n    }\n    \n    return { sections, patternMatches };\n}\n\n/**\n * Extract a clean title from a section heading\n * \n * @param line The heading line\n * @param patternIndex The index of the pattern that matched\n * @returns A clean section title\n */\nfunction extractSectionTitle(line: string, patternIndex: number): string {\n    // Clean up the title - remove excessive whitespace and punctuation\n    let title = line.trim();\n    \n    // Try to extract meaningful parts for special section types\n    if (/^\\s*(chapter|CHAPTER)\\s+(\\d+|[IVXLCivxlc]+)/i.test(title)) {\n        const match = title.match(/^\\s*(chapter|CHAPTER)\\s+(\\d+|[IVXLCivxlc]+)(?:[:.]\\s*(.*))?/i);\n        if (match) {\n            if (match[3]) {\n                // Chapter with title: \"Chapter 1: Introduction\"\n                return `${match[1]} ${match[2]}: ${match[3]}`;\n            } else {\n                // Just chapter number: \"Chapter 1\"\n                return `${match[1]} ${match[2]}`;\n            }\n        }\n    } else if (/^\\s*(\\d+|[IVXLCivxlc]+)\\.\\s+(.+)$/i.test(title)) {\n        // Format like \"1. The Beginning\"\n        const match = title.match(/^\\s*(\\d+|[IVXLCivxlc]+)\\.\\s+(.+)$/i);\n        if (match) {\n            return `Chapter ${match[1]}: ${match[2]}`;\n        }\n    } else if (/^\\s*(\\d+|[IVXLCivxlc]+)\\s*$/i.test(title)) {\n        // Just a number or Roman numeral\n        const match = title.match(/^\\s*(\\d+|[IVXLCivxlc]+)\\s*$/i);\n        if (match) {\n            return `Chapter ${match[1]}`;\n        }\n    }\n    \n    // For other patterns, just use the line as is\n    return title;\n}\n\n/**\n * Convert a sections map to an array of section objects\n * \n * @param sections Object mapping section titles to content arrays\n * @returns Array of section objects\n */\nexport function sectionsMapToArray(sections: { [title: string]: string[] }): Section[] {\n    return Object.entries(sections).map(([title, content]) => ({\n        title,\n        content\n    }));\n}\n\n/**\n * Format a section's content into a single string\n * \n * @param content Array of content lines\n * @returns Single formatted string\n */\nexport function formatSectionContent(content: string[]): string {\n    return content.join('\\n');\n}\n\n/**\n * Display sections in the DOM\n * \n * @param sections Object mapping section titles to content arrays\n * @param outputElement The HTML element to display the sections in\n */\nexport function displaySections(sections: { [title: string]: string[] }, outputElement: HTMLElement): void {\n    outputElement.innerHTML = ''; // Clear previous content\n\n    for (const title in sections) {\n        if (sections.hasOwnProperty(title)) {\n            // Create section title element\n            const sectionTitle = document.createElement('h2');\n            sectionTitle.textContent = title;\n            sectionTitle.className = 'text-lg font-semibold text-gray-800 mt-4 mb-2';\n            outputElement.appendChild(sectionTitle);\n\n            // Create container for section content\n            const contentContainer = document.createElement('div');\n            contentContainer.className = 'mb-4 text-gray-700';\n            \n            // Add each line of content as a paragraph\n            const content = sections[title];\n            if (content.length > 0) {\n                // Join content lines with appropriate spacing for paragraphs\n                for (const line of content) {\n                    if (line.trim().length > 0) { // Skip empty lines\n                        const paragraph = document.createElement('p');\n                        paragraph.textContent = line;\n                        paragraph.className = 'mb-2';\n                        contentContainer.appendChild(paragraph);\n                    } else {\n                        // Create spacing for empty lines\n                        const spacer = document.createElement('div');\n                        spacer.className = 'h-2';\n                        contentContainer.appendChild(spacer);\n                    }\n                }\n            } else {\n                // Show placeholder for empty sections\n                const emptyNotice = document.createElement('p');\n                emptyNotice.textContent = 'No content in this section';\n                emptyNotice.className = 'text-gray-400 italic';\n                contentContainer.appendChild(emptyNotice);\n            }\n            \n            outputElement.appendChild(contentContainer);\n        }\n    }\n}\n\n/**\n * Initialize event listeners for file input\n * \n * @param fileInputId The ID of the file input element\n * @param outputElementId The ID of the output element\n * @param patternString Optional regex pattern string for section detection\n */\nexport function initializeFileParser(\n    fileInputId: string, \n    outputElementId: string, \n    patternString: string = \"## Section \\\\d+\"\n): void {\n    document.addEventListener('DOMContentLoaded', () => {\n        const fileInput = document.getElementById(fileInputId) as HTMLInputElement;\n        const outputElement = document.getElementById(outputElementId) as HTMLDivElement;\n        \n        if (!fileInput || !outputElement) {\n            console.error(\"Could not find required elements:\", { fileInputId, outputElementId });\n            return;\n        }\n\n        fileInput.addEventListener('change', async (event) => {\n            const target = event.target as HTMLInputElement;\n            if (target.files && target.files.length > 0) {\n                const file = target.files[0];\n\n                try {\n                    // Read the file\n                    const text = await readFile(file);\n                    \n                    // Create pattern from string\n                    const pattern = new RegExp(patternString);\n                    \n                    // Parse the text into sections\n                    const { sections } = parseSections(text, [pattern]);\n                    \n                    // Display the sections\n                    displaySections(sections, outputElement);\n                } catch (error) {\n                    console.error(\"Error processing file:\", error);\n                    outputElement.innerHTML = `\n                        <div class=\"bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded\">\n                            <p class=\"font-medium\">Error processing file</p>\n                            <p class=\"text-sm\">${error instanceof Error ? error.message : 'Unknown error'}</p>\n                        </div>\n                    `;\n                }\n            }\n        });\n    });\n}", "/**\n * Text Parser - Standalone module\n * \n * This file serves as the entry point for the text parser module when used outside \n * of the React application. It exposes the core parsing functionality.\n */\n\nimport {\n  readFile,\n  parseSections,\n  formatSectionContent,\n  displaySections,\n  initializeFileParser\n} from './lib/textParser';\n\n// Make functions available in the global scope\n(window as any).TextParser = {\n  readFile,\n  parseSections,\n  formatSectionContent,\n  displaySections,\n  initializeFileParser\n};\n\n// Initialize the parser when the document is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n  console.log('Text Parser module loaded');\n  \n  // Find parser elements on the page\n  const fileInput = document.getElementById('fileInput');\n  const outputElement = document.getElementById('output');\n  \n  // If both elements exist, initialize the parser\n  if (fileInput && outputElement) {\n    initializeFileParser('fileInput', 'output');\n  }\n});"],
  "mappings": "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",
  "names": ["readFile", "file", "resolve", "reject", "reader", "event", "parseSections", "text", "patterns", "sections", "patternMatches", "lines", "currentSection", "currentContent", "beforeFirstSection", "foundFirstSection", "i", "line", "isHeading", "j", "extractSectionTitle", "patternIndex", "title", "match", "formatSectionContent", "content", "displaySections", "sections", "outputElement", "title", "sectionTitle", "contentContainer", "line", "paragraph", "spacer", "emptyNotice", "initializeFileParser", "fileInputId", "outputElementId", "patternString", "fileInput", "event", "target", "file", "text", "readFile", "pattern", "parseSections", "error", "readFile", "parseSections", "formatSectionContent", "displaySections", "initializeFileParser", "fileInput", "outputElement"]
}
